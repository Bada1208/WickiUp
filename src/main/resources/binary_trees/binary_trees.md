##Binary trees

 - How to run **Binary tree** applet:
 
   ```
   appletviewer http://cs.brynmawr.edu/Courses/cs206/spring2004/WorkshopApplets/Chap08/Tree/Tree.html
   ```
   
*Что такое дерево?*

Дерево состоит из узлов, соединенных ребрами.

![alt text](images/binary_tree1.png)

Ребра (соединительные линии между узлами) представляют отношения между узлами. Упрощенно говоря, программа может легко (и быстро) перейти от узла
к узлу, если между ними имеется соединительная линия. 
Обычно на верхнем уровне дерева располагается один узел, который соединяется с другими узлами на втором уровне; те, в свою очередь, соединяются с еще
большим количеством узлов на третьем уровне и т. д. Таким образом, деревья постепенно расширяются сверху вниз.

> Каждый узел двоичного дерева имеет не более двух потомков.

*Путь*

![alt text](images/binary_tree2.png)

*Корень*

> Узел на верхнем уровне дерева называется корневым узлом (корнем). Дерево имеет только один корень. 
> Чтобы совокупность узлов и ребер могла называться деревом, от корня к любому другому узлу должен вести один (и только один!) путь.
   
*Родитель*

> Любой узел (кроме корневого) имеет ровно одно ребро, уходящее вверх к другому узлу. 
> Узел, расположенный выше него, называется родительским узлом (или просто родителем) по отношению к данному узлу.   


*Потомок*

> Любой узел может иметь одно или несколько ребер, соединяющих его с узлами более низкого уровня. Такие узлы, находящиеся ниже заданного узла, называются его потомками.

*Лист*

> Узел, не имеющий потомков, называется листовым узлом (или просто листом).
> Дерево всегда имеет только один корень, но листьев может быть несколько.

*Поддерево*

> Любой узел может рассматриваться как корень поддерева, состоящего из его потомков, потомков его потомков и т. д.

*Посещение*

> Переход программы к узлу (обычно с целью выполнения некоторой операции,
> например проверки значения одного из полей данных или вывода) называется посещением.

*Обход*

> Обходом дерева называется посещение всех его узлов в некотором заданном порядке. 
> Например, все узлы дерева могут перебираться в порядке возрастания ключей.
> Как будет вскоре показано, существуют и другие способы обхода деревьев.

*Уровни*

> Уровенем узла называется количество поколений, отделяющих его от корня. 
> Если считать, что корень находится на уровне 0, то его потомки находятся на уровне 1, потомки потомков — на уровне 2 и т. д.

*Ключи*

> Одно из полей данных объекта часто назначается ключевым. Ключ используется при поиске элемента или выполнения с ним других операций.
> На древовидных диаграммах узел, содержащий данные, обычно обозначается кружком, а внутри кружка отображается значение ключа.

*Двоичное дерево*

> Если каждый узел дерева имеет не более двух потомков, такое дерево называется двоичным.
> Два потомка каждого узла двоичного дерева называются левым потомком и правым потомком в зависимости от позиции на изображении дерева


![alt text](images/binary_tree3.png)

---

*Класс Node*

Класс для представления объектов узлов.

```java
class Node{
    
    int iData; // Данные, используемые в качестве ключа
    Node leftChild; // Левый потомок узла
    Node rightChild; // Правый потомок узла
    
}
```
или более реальный пример из жизни

```java
class Node{
    
    Person p1; // Ссылка на объект person
    Node leftChild; // Левый потомок узла
    Node rightChild; // Правый потомок узла
    
}

class Person{
    
    int iData;
    double fData;
    
}
```

---

####Поиск

найти узел, представляющий элемент с ключом 57

![alt text](images/binary_tree4.png)

```java
public Node find(int key){ 
    
    Node current = root; // Начать с корневого узла
    while(current.iData != key){ // Пока не найдено совпадение
        if(key < current.iData){ // Двигаться налево?
            current = current.leftChild;
        }else{
            current = current.rightChild; // Или направо?
        } 
        if(current == null){ // Если потомка нет,
            return null; // поиск завершился неудачей
        } 
    }
    return current; // Элемент найден
}
```


